[Êó•Êú¨Ë™û](README.md)

> This README is based on content generated by AI and refined by the developer.
> Last updated: 250619

# `oso` ‚Äî An Experimental Pure Rust OS for AArch64

**`oso`** is a fully handcrafted operating system written in Rust, targeting the AArch64 architecture. It aims to leverage Rust's type safety and abstraction capabilities while pursuing low-level, direct hardware control ‚Äî with no external dependencies except for fundamental tools like QEMU and the Rust toolchain itself.

From its custom UEFI bootloader to a macro-driven kernel design, `oso` is an attempt to bring abstract reasoning to bare-metal development.

### Why AArch64?

AArch64 is chosen as the primary target for the following reasons:

- Though still underrepresented in online resources, it holds high potential ‚Äî `oso` aims to be both a pioneer and a reference in this space.
- It pushes the developer (myself) to cultivate independent problem-solving skills, relying not on blog posts, but on raw specification and self-reasoning.

---

## üîß Quick Start

Before running the commands below, make sure you've [installed the necessary tools](#build).

```bash
git clone https://github.com/sugiura-hiromiti/oso.git
cd oso
cargo xt
```

## Development Philosophy & Features

- [x] aarch64 targeted
- [x] pure Rust
- [x] no dependencies
  - External crates are used in the development auxiliary crate `xtask`
  - Additionally, external crates are used for the following purposes to prioritize my technical curiosity:
    - Web scraping: Automatically generating implementations with proc macros based on specifications
- [x] Standards compliant
  - Developed to respect de facto standards and minimize custom specifications
- [x] Active reinvention
  - Code is built from scratch based on primary sources (specifications and references) without copying existing implementations
  - This is to reinterpret the role and possibilities of OS during development and observe what OS and Rust can do from a level playing field
- [x] Active use of Rust's higher-order features
  - To explore Rust-specific advantages in OS development that existing projects have overlooked

## Project Structure

This repository is a [Cargo workspace](https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html) composed of multiple crates:

### oso_kernel

The core kernel crate.

Highlights:

- Uses many advanced nightly Rust features
- Modular structure:
  - app: Application runtime layer
  - base: Core abstractions and utilities
  - driver: Device drivers
  - gui: Graphical user interface
- Integrates with:
  - oso_bridge: Interface between bootloader and kernel
  - oso_binary_parser: Parses binary formats like DeviceTree (.dtb)
  - oso_proc_macro: Procedural macros for code generation
  - oso_error: Unified error handling framework

### oso_loader

A custom UEFI-compliant bootloader.

- Includes chibi_uefi: a minimalist UEFI wrapper written in Rust
- Supports ELF-based kernel loading
- Uses:
  - oso_bridge
  - oso_error

### xtask

Developer-focused CLI utilities.

- Builds for UEFI/QEMU environments
- Handles boot image creation and QEMU execution
- Automates deploy/test/dev flow

### Supporting Crates

| „ÇØ„É¨„Éº„ÉàÂêç             | Ë™¨Êòé                                                                         |
| ---------------------- | ---------------------------------------------------------------------------- |
| `oso_binary_parser`    | Provides a general framework for parsing ELF, DeviceTree, and other binaries |
| `oso_proc_macro_logic` | Internal logic and tests for procedural macro expansion                      |
| `oso_proc_macro`       | Macros for generating kernel structs, parsers, and test scaffolding          |
| `oso_error`            | Common error types and handling logic                                        |
| `oso_bridge`           | Shared interface structures between bootloader and kernel                    |

## build

Requirements:

- Rust (nightly)
- QEMU
- macOS (currently required due to use of hdiutil; multi-platform support is planned)

```bash
# Build all crates, mount binaries, and launch in QEMU
cargo xt

# Partial support for x86_64 as well
cargo xt -86
```
